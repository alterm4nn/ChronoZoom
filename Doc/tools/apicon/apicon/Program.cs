/******************************************************
 * This tool is designed to convert the XML generated by
 * Visual Studio into a Markdown-formatted document
 * for the REST API reference.
 * It is set up to extract the details from all members 
 * belonging to UI.ChronozoomSVC and magically convert it 
 * into Markdown. 
 * 
 * version 0.3 by William French
 ******************************************************/

using System;
using System.Collections;
using System.Collections.Generic;
using System.Configuration;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Xml;
using System.Xml.Linq;
using System.Xml.XPath;
using System.Xml.Xsl;
using System.IO;
using System.Text.RegularExpressions;
using System.Diagnostics;

namespace xslcon
{
    class MDConverter
    {
        /* Prefixes, regexes and paths defined in settings.
         * The prefixes are configurable since they could change.
         * The regexes are also configurable and should match
         * their corresponding member prefix string. */
        static string memberClass = Properties.Settings.Default.MemberClass;
        static Regex memberRgx = new Regex(Properties.Settings.Default.MemberRgx);

        static string entityTypeClass = Properties.Settings.Default.EntityTypeClass;
        static Regex entityTypeRgx = new Regex(Properties.Settings.Default.EntityTypeRgx);

        static string entityPropClass = Properties.Settings.Default.EntityPropClass;

        // These are the paths to the VS doc XML files we are going to process.
        static string memberPath = Properties.Settings.Default.MemberPath;
        static string entityPath = Properties.Settings.Default.EntityPath;

        // The top portion of the document.
        static string topMatter = Properties.Settings.Default.TopMatter;

        static void Main(string[] args)
        {
            generateMarkdown();            
        }

        // Run everything and output a file.
        static void generateMarkdown()
        {
            if(File.Exists(memberPath))
            {
                makeDoc(memberPath);
            }
        }

        // Uses Linq to get the names and output as array.
        static string[] getNames(string path, Regex rgx, string repl)
        {
            // Load the XML document.
            XDocument doc = XDocument.Load(path);

            // Create the stack to hold the names.
            Stack<string> nameStack = new Stack<string>();

            // Get all of the names.
            var query =
                from member in doc.Descendants("member")
                select
                    new XElement("member",
                                    member.Attribute("name").Value);

            // Filter and clean the strings.
            foreach (var member in query)
            {
                if (rgx.IsMatch(member.Value))
                {
                    string n = cleanString(member.Value, repl);
                    nameStack.Push(n);
                }
            }

            // Make array, flip values and output.
            string[] nameArray = nameStack.ToArray();
            Array.Reverse(nameArray);
            return nameArray;
        }

        // Get all of the members and return MarkDown.
        static string getMembers(string path)
        {
            // Load the XML document.
            XDocument doc = XDocument.Load(path);

            StringBuilder sb = new StringBuilder();

            // Get all of the members.
            var qMembers =
                from member in doc.Descendants("member")
                where (memberRgx.IsMatch(member.Attribute("name").Value))
                select
                    member;

            // Add each member to the doc.
            foreach (var member in qMembers)
            {
                    sb.AppendLine("### " + cleanString(member.Attribute("name").Value, memberClass) + " ###");
                    sb.AppendLine(" ");
                    sb.AppendLine(member.XPathSelectElement("summary").Value.Trim());
                    sb.AppendLine(" ");

                    if (member.XPathSelectElement("returns") != null)
                    {
                        sb.AppendLine("**Returns**");
                        sb.AppendLine(member.XPathSelectElement("returns").Value.Trim());
                        sb.AppendLine(" ");
                    }

                    if (member.XPathSelectElement("example") != null)
                    {
                        sb.AppendLine("**Example**");
                        string ex = member.XPathSelectElement("example").Value;
                        ex = cleanExample(ex);
                        sb.AppendLine(ex);
                        sb.AppendLine(" ");
                    }

                    var qParams =
                        from p in member.Descendants("param")
                        select
                            p;

                    if (qParams.Count() != 0)
                    {
                        sb.AppendLine("**Parameters**");
                        sb.AppendLine(" ");
                        sb.AppendLine("|Parameter|Value|");
                        sb.AppendLine("|:--------|:----|");

                        foreach (var param in qParams)
                        {
                            sb.AppendLine("|" + param.FirstAttribute.Value + "|" + param.Value + "|");
                        }
                        sb.AppendLine(" ");
                    }
                    else
                    {
                        sb.AppendLine("**Parameters**");
                        sb.AppendLine("None.");
                        sb.AppendLine(" ");
                    }

                    if (member.XPathSelectElement("remarks") != null)
                    {
                        sb.AppendLine("**Remarks**");
                        sb.AppendLine(cleanExample(member.XPathSelectElement("remarks").Value.Trim()));
                        sb.AppendLine(" ");
                    }

                    sb.AppendLine(" ");
                    sb.AppendLine("[top](#chronozoom-rest-api-reference)");
                    sb.AppendLine(" ");
                    sb.AppendLine("----------");
                    sb.AppendLine(" ");
            }

            return sb.ToString();
        }

        // Get all of the entities and return MarkDown.
        static string getEntities(string path)
        {
            // Load the XML document.
            XDocument doc = XDocument.Load(path);

            StringBuilder sb = new StringBuilder();

            // Get all of the entities.
            var qEntityTypes =
                from member in doc.Descendants("member")
                where (entityTypeRgx.IsMatch(member.Attribute("name").Value))
                select
                    member;

            foreach (var member in qEntityTypes)
            {
                string nameString = cleanString(member.Attribute("name").Value, entityTypeClass);

                //@"P:Chronozoom\.Entities\.Bookmark\.\w*"
                Regex entityPropRgx = new Regex(@"P:Chronozoom\.Entities\." + nameString + @"\.\w*");

                var qEntityProps =
                    from pmember in doc.Descendants("member")
                    where (entityPropRgx.IsMatch(pmember.Attribute("name").Value))
                    select
                        pmember;

                sb.AppendLine("### " + nameString + " ###");
                sb.AppendLine(" ");
                sb.AppendLine(member.Element("summary").Value.Trim());
                sb.AppendLine(" ");

                var qParams =
                    from p in member.Descendants("param")
                    select
                    p;

                if (qParams.Count() != 0)
                {
                    sb.AppendLine("|Enum|Value|");
                    sb.AppendLine("|:--------|:----|");

                    foreach (var param in qParams)
                    {
                        sb.AppendLine("|" + cleanString(param.FirstAttribute.Value, entityPropClass + nameString) + "|" + param.Value + "|");
                    }
                }

                if (qEntityProps.Count() != 0)
                {
                    sb.AppendLine("|Property|Value|");
                    sb.AppendLine("|:-------|:----|");


                    foreach (var prop in qEntityProps)
                    {
                        // P:Chronozoom.Entities.[member].[prop]
                        string propName = cleanString(prop.FirstAttribute.Value, entityPropClass + nameString + ".");
                        sb.AppendLine("|" + propName + "|" + prop.Value.Trim() + "|");
                    }
                }

                sb.AppendLine(" ");
                sb.AppendLine("[top](#chronozoom-rest-api-reference)");
                sb.AppendLine(" ");
                sb.AppendLine("----------");
                sb.AppendLine(" ");
            }

            return sb.ToString();
        }

        // Clean up name string.
        static string cleanString(string n, string repl)
        {
            n = n.Replace(repl, "");
            int i = n.IndexOf("(");
            if (i > 0)
            {
                n = n.Remove(i);
                return n;
            }
            else
            {
                return n;
            }
        }

        // Clean up example code (extra spaces since they are in CDATA in the source).
        private static string cleanExample(string ex)
        {
            string aLine, fullExample = "";
            StringReader sr = new StringReader(ex);
            while (true)
            {
                aLine = sr.ReadLine();
                if (aLine != null)
                    fullExample += aLine.Replace("             ", "    ") + "\n";
                else
                    return fullExample;
            }

            return fullExample;
        }

        // Output a table of contents.
        static string makeToc(string[] input)
        {
            StringBuilder sb = new StringBuilder();
            
            for (int i = 0; i < input.Length; i++)
            {
                string item = input[i].ToString();
                string tocLine = "- [" + item + "](#" + item.ToLower() + ")";
                sb.AppendLine(tocLine);
            }

            return sb.ToString();
        }

        static void makeDoc(string path)
        {
            StringBuilder sb = new StringBuilder();

            // Add the top part of the doc.
            using (StreamReader sr = new StreamReader(topMatter))
            {
                String line = sr.ReadToEnd();
                sb.AppendLine(line);
            }

            // Get the entity names and add the TOC.
            sb.AppendLine("## ChronoZoom Entities ##");
            string[] enames = getNames(entityPath, entityTypeRgx, entityTypeClass);
            string etoc = makeToc(enames);
            sb.AppendLine(etoc);

            // Get the entities and build the reference portion.
            string entities = getEntities(entityPath);
            sb.AppendLine(entities);

            // Get the member names and add the TOC.
            sb.AppendLine("## ChronoZoom REST Commands ##");
            string[] mnames = getNames(memberPath, memberRgx, memberClass);
            string mtoc = makeToc(mnames);
            sb.AppendLine(mtoc);

            // Get the members and build the reference portion.
            string members = getMembers(memberPath);
            sb.AppendLine(members);

            using (StreamWriter outfile = new StreamWriter(Properties.Settings.Default.OutFile))
            {
                outfile.Write(sb.ToString());
            }
        }
    }
}
